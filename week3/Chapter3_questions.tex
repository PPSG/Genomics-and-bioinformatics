\documentclass[a4paper,11pt]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{bbm} %math chars
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{fullpage} %minimizes the default margins
\usepackage{url}
\usepackage{graphicx}
\usepackage[center,footnotesize]{caption}
\usepackage[section]{placeins}
\usepackage{subfig}

\title{Series 3}
\date{October 3, 2011}
\author{Genomics and bioinformatics - Week 3}

\begin{document}
\maketitle

\section{Learning objectives}
The final goal of the programming exercises you receive each week is for you to be able to download some interesting data files from UCSC, format them, extract the relevant data from them and apply some statistics that you have seen in this course. At the end of the fourteenth week, you should be able to answer many different types of biological questions by fetching the data needed and using some existing software necessary for the analysis or writing the code necessary for the analysis yourself.

\section{Today's exercise}
We are going to create a contig from a bunch of reads. The reads have been specially created by the assistants for this problem and will be given to you on the Moodle website. Your goal is to generate the largest contig possible. We will consider a simplified ideal case where:
\begin{itemize}
\item The reads don't contain any errors.
\item The reads have the same length.
\item The reads are all from the same strand.
\item No two reads are the same.
\item The full chromosome of our imaginary species is small.
\end{itemize}
See the last section of this document to learn some useful Python tricks.

\subsection{Hamiltonian path problem}
\begin{enumerate}
\item Read the file \texttt{reads1.fastq} and load all the reads it contains inside a list. It may help you to take a look at \texttt{reads1.fastq} in your text editor first.
\item Write a function that takes two reads as input and returns first read extended with the second; if they don't overlap, return \texttt{False}. The function should also have a \texttt{min\_overlap} parameter that specifies how many base pairs must match between both reads at a minimum for it to be considered an overlap. \\
e.g. \texttt{overlaps(AATG,TGTT,2) -> AATGTT , overlaps(AATG,TGTT,3) -> False}
\item Using the the list of reads you just loaded and the function you just wrote, you can now generate a list of vertices and a list of edges of the overlap graph - i.e. the reads will act as the vertices and the overlaps as the edges. In our case, a edge between two reads exists if the first overlaps the second.
\item Copy the code from \texttt{findcycles.py} into your code (or import its functions).
\item Use the function \texttt{bruteforce(edges)} to get an Hamiltonian path from your graph. Deduce the largest contig possible, and display it on the screen.
\item Record the time it takes to compute: import the \texttt{time} library and use \texttt{time.time()} to get the current time.
\item The contig should be AATGTCGATT. If you get it right, you can try to build more reads and run it again.
\item Now try it on \texttt{reads2.fastq}.
\end{enumerate}

\subsection{Eulerian path problem (de Bruijn algorithm)}
\begin{enumerate}
\item Write a function that for a given read returns a list of all the l-mers contained in the read, \\
e.g. \texttt{subseqs(AATGCG,4) ->  [AATG,ATGC,TGCG]}
\item Taking \texttt{l} = 3 bp, and using the same reads library as before, generate the list of vertices and the list of edges as defined for the de Bruijn graph.
\item Spot the start and end vertices (in our case, the ones that appear only once in the edges), and add one vertex to close the graph.
\item Use the \texttt{hierholzer(nodes,edges)} function - that you copied or imported earlier - to find an Eulerian cycle in your graph. Deduce the largest contig possible for \texttt{reads1.fastq}, and display it on the screen. Record the time it takes to compute, and compare with the Hamiltonian case.
\end{enumerate}

\subsection{Useful Python features}
\begin{enumerate}
\item Use list comprehensions:\\
\texttt{[x+4 for x in [1,2,3]]} \\
returns \texttt{[5,6,7]} \\
\texttt{[(x,y[0]) for x in [1,2] for y in [[1,2],[3,4]] ]}\\
returns \texttt{[(1, 1), (1, 3), (2, 1), (2, 3)]}
\item No need to add ``\texttt{;}'' at the end of your lines. You can do it though if you want to put several statements on the same line.
\item You can use \texttt{list(set(...))} to get only unique elements of a list. Unfortunately there exists no such built-in function in Python.
\item Use \texttt{dir(object)} to get all possible methods for this object. If you are using Ipyhon as advised, just type \texttt{object.} and hit the ``tab'' key.
\end{enumerate}

\end{document}
